## 线性表
##### 1.线性表索引为什么从零开始
	这涉及到内存结构算法，例如我们分配一个长度为10的int类型数组，内存地址分配1000-1039，然后对内存进行随机访问时
	可以直接使用公式 access_addr=base_addr + data_type * i (i代表要访问的位置)
##### 2.关于线性表批量删除优化
	为了保证线性表的连续性，我们经常会在删除一个元素后，马上将其后面的元素向前移位来避免碎片。而在批量删除时，我们可
	以先进行删除，最后集中整理碎片的思路，通过减少移动元素次数，来达到优化的目的。
	
### 查找
##### 1.对比几种常用查找数据结构：AVL-Tree、RB-Tree、B+Tree、Skip-List
	1.对比AVL-Tree和RB-Tree，虽然同样作为BST，AVL-Tree属于严格平衡，因此在查找效率更高，但维护节点时，效率会很低，需要进行O(logN)次旋转;
	  而RB-Tree在维护节点时，最多只需要3次旋转即可，属于O(1)量级，但查找效率略逊于AVL-Tree。总体而言，RB-Tree是功能、性能、空间开销折中的数
	  据结构，因此在生产级别代码中，RB-Tree更为常见（例如JDK.TreeMap、linux内核）。
	  如果读并发大，但写很少，可以采用AVL-Tree；但如果读写都很频繁，相对AVL-Tree，RB-Tree的性能更好一些，也更通用一些。
	2.B+Tree属于多路搜索树，且为了方便磁盘检索，子节点之间有指针相连，可以很方便的读到连续数据。
	3.Skip-List是在Redis中看到的数据结构，对比RB-Tree，Skip-List多层级索引，可以根据Range进行查找，这点是RB-Tree做不到的。